# -*- coding: utf-8 -*-
"""Drought Farms.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dyLLpmdLivabkFsNMMra9zxaHsYVdCNg

# Finding Ideal Land for Farms in Areas of Drought
Research by Arman Bhalla
"""

!pip install sentinelhub --upgrade

!sentinelhub.config --show

!sentinelhub.config --instance_id e8a19352-2581-4ad3-9168-816b7bce2097

# %reload_ext autoreload
# %autoreload 2
# %matplotlib inline
import datetime
import numpy as np

import sys
from PIL import Image

import matplotlib.pyplot as plt
from sentinelhub import WmsRequest, WcsRequest, MimeType, CRS, BBox

def plot_image(image, factor=1):
    """
    Utility function for plotting RGB images.
    """
    fig = plt.subplots(nrows=1, ncols=1, figsize=(15, 7))

    if np.issubdtype(image.dtype, np.floating):
        plt.imshow(np.minimum(image * factor, 1))
    else:
        plt.imshow(image)

betsiboka_coords_wgs84 = [46.16, -16.15, 46.51, -15.58]
betsiboka_bbox = BBox(bbox=betsiboka_coords_wgs84, crs=CRS.WGS84)

"""## Data Entry Point
Change your BBox to the WGS 84 co-ordinates of the area you want to analyse. 
This is a helpful tool to get this info: https://epsg.io/map#srs=4326&x=0.000000&y=0.000000&z=1&layer=streets
"""

# testing different coordinate system thing
# bounds = [35.16, -15.15, 35.51]
#bounds_bbox = BBox(bbox=bounds, crs=CRS.WGS84)
wms_ndwi_req = WmsRequest(layer='NDWI',
                                    bbox=betsiboka_bbox,
#                                     time='2017-12-15',
                                    width=512, height=856,
                                    instance_id="e8a19352-2581-4ad3-9168-816b7bce2097")
wms_vegetation_req = WmsRequest(layer='NDVI',
                                    bbox=betsiboka_bbox,
#                                     time='2017-12-15',
                                    width=512, height=856,
                                    instance_id="e8a19352-2581-4ad3-9168-816b7bce2097")
wms_ndwi = wms_ndwi_req.get_data()
wms_vegetation = wms_vegetation_req.get_data()

print(wms_vegetation)
print(wms_ndwi)

"""The variable **sum** here is where our final map is. This is the list of figure 3."""

print(wms_vegetation[0]+wms_ndwi[0])
# The sum of vegetation and true colour images
sum = wms_vegetation[0]+wms_ndwi[0]

#print('Returned data is of type = %s and length %d.' % (type(wms_ndwi), len(wms_ndwi)))
#print('Single element in the list is of type {} and has shape {}'.format(type(wms_ndwi[-1]), wms_ndwi[-1].shape))
print("Fig 1: NDWI WATER SCALE, the darker, the better")
plot_image(wms_ndwi[-1]) # water
print("Fig 2: NDVI VEGETATION SCALE, the more concentrated, the better")
plot_image(wms_vegetation[-1]) #vegetation
print("Fig 3: SUPERIMPOSED UPON EACH OTHER, more concentrated + more dark the better")
plot_image(sum)

!pip install weather-api

"""# Data Entry Point
Enter the long and lat from the darkest point which is NOT sea and is within your plot of land from above.
Ideally there would be a method to do this automatically, but due to time constraints, I've not implemented this.
"""

from weather import Weather, Unit
weather = Weather(Unit.CELSIUS)
#enter the lat and long NOT IN WGS 84 EPSG PROJECTION SYSTEM. JUST NORMAL LATITUDE AND LONGITUDE OF THE SITE YOU FIND OUT
lookup = weather.lookup_by_latlng(53.3494,-6.2601)
condition = lookup.condition
forecasts = lookup.forecast
avg_highlow_delta = 0
for forecast in forecasts:
#     print(forecast.text)
#     print(forecast.date)
#     print(forecast.high)
#     print(forecast.low)
    avg_highlow_delta += int(forecast.high) + int(forecast.low)
# average it over the number of forecasts
avg_highlow_delta/=7
print(avg_highlow_delta)

"""This is where we start to use the data from the weather and the NDWI water scale and NDVI scale plot."""

import scipy, sklearn
import numpy as np
from sklearn import tree

"""INPUT:  * The longitude (x axis of the superimposed plot) and latitude (y axis of the superimposed plot)
              * Weather avg_highlow_delta
              * region number (to-do)
              
 OUTPUT: 
 * Farm yes, farm no
"""

#X_net = []
#def train():
  # Here, brute force the longitude and latitude, query the satelite, and collect training data.
 # X_train = []
  #return null

# in the future we'll use decision trees, but training and testing datasets aren't openly available without brute forcing requests to the satelite... which would take ages... so we are just going to do this with plain weights

"""What this is doing is using a makeshift scale with weights, which takes in the weather high-low average delta for this week, longitude, and latitude. From long and lat it gets the intensity from FIGURE 3 in the earlier plots - so the superimposed graph.
It will then repeat this for all longitudes specified in the bounding area, with their respective latitudes.
"""

#dummy, we'd be getting this from the plot
values_for_all_long = [10,20,30,40,50,60,70,80,90,100]
#dummy, we'd be getting this from the plot
values_for_respective_lat = [90, 80, -16, 28, 30, 40, 60, 80, -18, -12]

def calculate_scale(long, lat, weather):
  #first get the intensity from the superimposed graph with these longitude and latitude
  # we do this by longitude (as it's on the x axis of the plot)
  # print(wms_vegetation[0][10][-1]) this gets what the intensity is when longitude = 10 and latitude is the last value possible (so the largest latitude) 
  WEATHER_WEIGHT = 0.25
  INTENSITY_WEIGHT = 0.75
  intensity = 0
  for i in range(0, len(values_for_all_long)):
    respective_lat = values_for_respective_lat[i]
    respective_long = values_for_all_long[i]
    #this intensity is the NDWI + NDVI
    intensity += sum[0][respective_lat][respective_long]    
  weighted_value = 1+(WEATHER_WEIGHT * weather)+(INTENSITY_WEIGHT * intensity)

"""### The value from the scale
calculate_scale() returns a weighted sum. You need to plug IN:
* longitude and latitude that is dark + concentrated from map figure 3
* weather high-low delta from the current week (this is from the avg_highlow_delta)
"""

YOUR_LONG = 0 
YOUR_LAT = 0
print(calculate_scale(YOUR_LONG, YOUR_LAT, avg_highlow_delta))

"""Copyright Arman Bhalla, 2018. All Rights Reserved."""